对FSMC地址操作的一点认识

首先说一个前提：STM32 单片机的一个地址(如:0x20000000)是一个字节
也就是说如果定义一个16位数组 u16 temp[5]  如果temp对应的地址是0x00000000 那么temp+1对应的地址是0x00000002 (地址是加2)

假设此时我们有一个 64K*8bit 的sram
那很简单 stm32的A0~A15 与存储器A0~A15连接 大家很容易理解

若此时是 64K*16bit 的sram
也就是此时sram的一个地址对应两个字节 但是stm32是一个地址一个字节 这就出现了对准的问题
如果我们的地址线依然是stm32A0~A15 和 存储器的A0~A15 连接 
如果stm32要从sram中读取前面提到数组中的temp[1]
stm32会给出0x0002（二进制地址0000000000000010b） 可是对于我们这个sram来说 读到却是temp[2]，因为sram一个地址就是一个16位数据 
为了解决这个问题 我们只需要在给sram送地址时 右移一位 再送地址 即可（sram的一个地址对应stm32两个地址的数据）
比如读取0x0002 右移一位（即除2）为0x0001(0000000000000010b) 此时对应的就是temp[1]
而为了给用户提供方便 如果你选择的是16位宽度的sram FSMC会在你送地址的时候自动为你做右移一位的操作 
此时会有另外一个问题 每次都右移一位 A0没用吗 也即只能读写偶地址的数据吗？
这也就是NBL0和NBL1的作用了 如果你要进行字节操作 
如stm32发送地址0x0001读取一个字节 右移一位对应的是sram地址0x0000处的16位数据 FSMC会根据AO 来控制NBLO和NBL1为10 读取高字节数据
所以呢  偶字节读写时仅NBL0有效，奇字节读写时仅NBL1有效 字读写都有效（低电平有效）